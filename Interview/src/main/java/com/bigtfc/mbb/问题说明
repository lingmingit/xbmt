




对大文本文件进行统计遇到的问题:
3、拆分文件数量选择
     拆分文件线程统计数量是由源文件大小决定，因为是多线程异步同时执行统计，主要是根据拆分后文件大小决定，
     如果源文件越大，拆分线程数量大，被拆分的文件大小就越小，每个线程统计效率就越快；如果源文件小，拆分线程数量就不用多大，统计效率也比较快；
     
2、MappedByteBuffer内存映射方法 map 第三个参数
   例如，要映射100到299（包含299）位置的字节，可以使用下面的代码： 
   buffer = fileChannel.map (FileChannel.MapMode.READ_ONLY, 100, 200);
     如果要映射整个文件则使用： buffer = fileChannel.map(FileChannel.MapMode.READ_ONLY, 0, fileChannel.size()); 
  http://zheng12tian.iteye.com/blog/1100721
     其中第三个参数为映射文件的size大小，而不是结束位置，否则 就会出现源文件大小增加 （如果您请求一个超出文件大小的映射，文件会被增大以匹配映射的大小。） 
    index = 0(从0开始)
   long start = index * numPerThred;//起始位置
   long end = (i + 1) * numPerThred;//结束位置
   long size = numPerThred;  //应该用size，就是平均拆分大小，而不是结束位置
1、由于使用多个线程将源文件进行拆分统计，但是不能明确什么时间拆分文件统计完成，再进行总的统计？
      解决方法：
     1.1、拆分文件统计线程启动后，使用线程等待时间（等待拆分线程统计完成后，再进行汇总统计）Thread.sleep(20000);  
     	优点：比较简单实现
     	缺点：适合于源文件比较小的时候，如果文件比较大，不能确定等待多久时间
     1.2、将拆分文件线程统计结果写入新的文件中，等待所有拆分统计文件生成后，再进行汇总统计
                       优点：将拆分文件统计 和 最后汇总统计分为两步实现，拆分统计线程完成后，就会生成统计文件，不用明确设置需要等待多长时间
                       缺点：实现过程复杂一些，反复读文件、写文件再读文件
     1.3、再开启一个新统计线程，监控所有的拆分线程状态，当前都执行完成后，即进行汇总统计
                      优点：不用明确设置需要等待多长时间，由统计线程自动监控拆分线程状态
                      缺点：实现过程复杂一些，如果拆分线程较多，每一个都要进行状态判断
                